#### 背景

对于一个有序的链表，尽管其是有序的的，但由于其存储空间不连续，要想查到这个元素仍然需要遍历整个链表,时间复杂度为O(n)。

于是可以考虑对链表进行索引，比如在该链表的基础上建立一个二级的链表，隔着若干个元素到第二个节点，往上依次类推，容易根据数学公式证明，上层索引相对下层索引间隔二时，其时间复杂度最小，此时的查找类似于二分，故而时间复杂度为O(logn)，而对于其空间复杂度，上层所要开的空间总是下层的一半，故而其空间复杂度由等比数列求和易得，只额外开了一个O(n)的空间，这样的数据结构称为跳表

#### 出现的问题

如果按照上述所说的方式，尽管对一个已经建好的跳表可以做到查询时间复杂度为O(logn),但若频繁向这个跳表中插入不随机的数据，很有可能在上层两个索引的节点之间产生大量节点，从而时间复杂度又变回O(n),故而有一个如下的优化方案，每次插入新节点时，通过随机数确定其产生的节点高度，（1/2）^n表示n层高度，容易证明这样的跳表的数学期望满足之前所期望的理想跳表

#### 详细的数据结构

~~~
struct node{
	int data;
	int level;
	node * nex[maxlevel];
}//每一个节点，有若干个往后的指针，指向k层后续的节点
struct skiplist{
	node *head;//有一个头指针指向首节点方便遍历
}
//详细的实现见代码
~~~

