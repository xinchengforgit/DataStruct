#### 一般的树的存储法

对于一般的树的储存方法,大致有两种，一是兄弟儿子树，对于同一个父亲节点的所有儿子，从第一个儿子开始，它的左指针指向第一个儿子，右指针指向它的兄弟由此构建树的结构

而第二种就是，将树看成图，利用邻接表法储存树结构,思路如下

每次往图(树中)加边时，将新边指向这两个顶点的边表的首部，然后将

顶点表的指针指向新边



#### 二叉树的存储方法

对于一个二叉树其基本的储存方法就是那数据域存储数值，用左右两个指针指向其左儿子或者右儿子

#### morris遍历

对于一般的遍历进行前中后三种方法遍历时，或是需要通过手动压栈，或是系统自动调用栈来储存状态故其空间复杂度为O(h),h为树的高,故而可以在不改变时间复杂度的情况下，改进空间复杂度，使用morris遍历，其核心之处在于利用了空闲的右指针指向当前位置，从而快速的地位

大致的图如下

![image-20210415161910253](C:\Users\leh\AppData\Roaming\Typora\typora-user-images\image-20210415161910253.png)

首先考虑某个节点，如果该节点有左儿子，那么考虑其左儿子的最右边的节点，如果此时指针为空那么指向当前节点，节点左移，否则改为空，节点向右移动给，如果没有左儿子，则节点直接向右移动。

容易证明出对于一个有左儿子的节点，必然会在上述过程中经过2次，而对于只有右儿子的节点，只会经过一次，故而证明了morris遍历的时间复杂度为O(N),

在进一步观察遍历过程可知，当第二次经过某节点时，其左树已经遍历完成，

当第一次经过这个节点时，其左树尚未开始遍历，故而可以通过这个特性实现前序和中序遍历

后序遍历相对比较复杂，通过归纳法可知，当第二次经过某节点时，逆序打印其左子树的右边界所构成的序列就是他的后序遍历序列